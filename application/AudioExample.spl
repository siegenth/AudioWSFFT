namespace application ;

use com.ibm.streamsx.inet.rest::HTTPTupleView ;
use com.ibm.streamsx.inet.wsserver::WebSocketInject ;
use com.ibm.streamsx.inet.rest::WebContext ;
use com.ibm.streamsx.json::JSONToTuple ;
use com.ibm.streamsx.json::TupleToJSON ;
use com.ibm.streamsx.inet.wsserver::WebSocketSend ;
use com.ibm.streams.timeseries.analysis::* ;
use com.ibm.streams.timeseries.analysis::FFT ;
type BinaryDataType = tuple<blob outBlob> ;
type AudioDataType = tuple<rstring id, rstring command, uint64 size,
	blob outBlob, rstring signalData> ;
type AudioSignalType = tuple<rstring id, rstring signalData> ;
type AudioCommandType = tuple<rstring id, rstring command,
	rstring commandData> ;
type AudioSampleType = tuple<rstring id, float32 sample> ;
type AudioFFTType = tuple<rstring id, list<float64> magnitude> ;
type AudioSample64Type = tuple<rstring id, float64 sample> ;
type AudioFFTAmpType = tuple<rstring id, list<float64> ampFFT> ;
type AudioTileType = tuple<rstring id, list<float64> tile> ;
type AudioQuantileType = tuple<rstring id, float64 tile1, float64 tile2,
	float64 tile3, float64 tile4> ;
type SimpleTuple = tuple<rstring data> ;
int64 getMilliseconds(timestamp ts)
{
	return(getSeconds(ts) * 1000l) +(int64)(getNanoseconds(ts) / 1000000u) ;
}
/**
 * Convert A 2 character string to binary value.
 * Yes this can be collapsed, but you can see this. 
 */
uint8 hexToInt(list<uint8> cvt)
{
	mutable uint8 l, h ;
	mutable uint8 low, high ;
	l = cvt [ 0 ] -(uint8) 48 ;
	h = cvt [ 1 ] -(uint8) 48 ;
	list<uint8> mapp = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0, 10,
		11, 12, 13, 14, 15 ] ;
		//////////////////// 0, 1, 2, 3, 4, 5, 6. 7, 8, 9, :, ;, <, =, >, ?, @,  A, B, C, D, E, F
	low = mapp [ l ] << 4 ;
	high = mapp [ h ] ;
	return(low | high) ;
}

composite AudioSample
{
	graph
		() as WebContext_3 = WebContext()
		{
			param
			// URL : http:<IP>:8081//html gets to index.thml 
			//       in "/home/streamsadmin/Development/html" ;  
				context : "html" ; // notice, no leading '/',  
				//contextResourceBase : getThisToolkitDir() + "/opt/html" ;
				// set to development directory so I can change things rapidly,
				// without redeploying the application. 
				//contextResourceBase : "/mnt/streamsadmin/Development/html" ;
				//contextResourceBase : "/xxxxx";
				contextResourceBase : "/mnt/hgfs/shareVM/CROSSDEV/audio/opt/html" ;
				// NOTE the only way I got this to work is to mess up the Data directory
				// that is set on the build??? I should be to the opt directory. 
				port : 8080 ;
			config
				placement : partitionColocation("jettyStatus") ;
		}

		(stream<rstring data> WebSocketInject_2_out0) as WebSocketInject_2 =
		//(stream<list<uint16> data> WebSocketInject_2_out0) as WebSocketInject_2 =
		WebSocketInject()
		{
			param
				port : 8086 ;
			config
				placement : partitionColocation("jettyStatus") ;
		}

		(stream<AudioDataType> Custom_7_out0 as DataOut ; stream<AudioCommandType>
			Custom_7_out1 as ControlOut) as WSSocketProcess =
			Custom(WebSocketInject_2_out0 as RawIn)
		{
			logic
				state :
				{
					mutable int32 messageCount = 0 ;
					list<uint8> resetOut = [ ] ;
					mutable list<uint8> out ;
					mutable BinaryDataType bdt ;
					mutable list<uint8> cvt ;
					mutable int32 hash1, hash2 ;
					mutable AudioDataType adt ;
					mutable AudioCommandType act ;
				}

				onTuple RawIn :
				{
					messageCount ++ ;
					out = resetOut ;
					if((length(data) != 0) &&(data [ 0 ] == "#"))
					{
						hash1 = findFirst(data, "#", 1) ;
						if(hash1 != - 1)
						{
							hash2 = findFirst(data, "#", hash1 + 1) ;
							if(hash2 != - 1)
							{
								adt.id = data [ 1 : hash1 ] ;
								adt.command = data [ hash1 + 1 : hash2 ] ;
								if((messageCount % 10) == 0)
								{
									appLog(Log.info, "messageCount:" +(rstring) messageCount + " id:" +
										adt.id + " command:" + adt.command + " length:" +(rstring)
										length(data)) ;
								}

								if(adt.command == "DATA")
								{
									cvt =(list<uint8>) convertToBlob(data [ hash2 + 1 : ]) ;
									for(int32 i in range(0, size(cvt), 2))
									{
										appendM(out, hexToInt(cvt [ i : i + 2 ])) ;
									}

									adt.outBlob =(blob) out ;
									adt.size = blobSize(adt.outBlob) ;
									adt.signalData = data [ hash2 + 1 : ] ;
									submit(adt, DataOut) ;
									return ;
								}

								act.command = adt.command ;
								act.id = adt.id ;
								act.commandData = data [ hash2 + 1 : ] ;
								appLog(Log.info, "ID: " + act.id + " COMMMAND:" + act.command) ;
								if(act.command == "STOP")
								{
									submit(Sys.WindowMarker, DataOut) ;
								}
								// All commands other the 'DATA' are sent down the line. 
								submit(act, ControlOut) ;
								return ;
							}

						}

					}

					act.id = "*UNKNOWN ID*" ;
					act.command = "UNKNOWN MESSAGE" ;
					act.commandData = data ;
					appLog(Log.warn, "Unknown message received : " + act.commandData [ : 40
						]) ;
					submit(act, ControlOut) ;
				}

		}
		/** 
		 * Only send out the binary data to file. 
		 */
/* 
		(stream<BinaryDataType> Functor_8_out0) as StripBlobAudio =
			Functor(Custom_7_out0 as wavStreamOut)
		{		}
		* */

/**
		 * Write the binary data, when file closes send down the file name.
		 */
/* 
		(stream<rstring fileName> FileSink_7_out1) as WriteBlobAudio =
			FileSink(Functor_8_out0 as inPort0Alias)
		{
			param
				file : "/tmp/STRM{localtime:%d%M}{id}.wavraw" ;
				closeMode : punct ;
				format : block ;
				flush :(uint32) 1 ;
		}

		(stream<AudioCommandType> Functor_7_out0) as FileNameFormat =
			Functor(FileSink_7_out1)
		{
			output
				Functor_7_out0 : id = "?", command = "STOP file closed", commandData =
					fileName ;
		}

		() as TraceSink = Custom(Custom_7_out1, Functor_7_out0 as inputStream)
		{
			logic
				onTuple inputStream :
				{
					appLog(Log.info, " ID:" + inputStream . id + "command:" + command + ":" +
						commandData) ;
				}

		}
*/
		() as WebSocketSend_8 = WebSocketSend(Aggregate_6_out0 as inPort0Alias)
		{
			param
				port : 8087 ;
			config
				placement : partitionColocation("jettyStatus") ;
		}

		(stream<AudioSampleType> Custom_10_out0 as O) as SampleGenerator =
			Custom(Custom_7_out0 as I)
		{
			logic
				state :
				{
					mutable AudioSampleType audioSample ;
					mutable uint64 bufLen = 0 ;
					mutable uint8 hByte ;
					mutable uint8 lByte ;
					mutable int16 word ;
				}

				onTuple Custom_7_out0 :
				{
					assignFrom(audioSample, I) ;
					// bufLen = blobSize(I.outBlob);
					for(int32 idx in range((int32) 0,(int32) blobSize(I.outBlob),(int32) 2))
					{
						hByte = outBlob [ idx + 1 ] ;
						lByte = outBlob [ idx ] ;
						word =(int16)((int16) hByte << 8 |(int16) lByte) ;
						audioSample.sample =((float32) word /(float32) 32767.0) ;
						appTrc(Trace.trace,(rstring) hByte + ":" +(rstring) lByte + "::"
							+(rstring) word + "->" +(rstring) audioSample.sample) ;
						submit(audioSample, O) ;
					}

					//submit(audioSample, O) ;

				}

				onPunct Custom_7_out0 : submit(Sys.WindowMarker, O) ;
		}
		/* 
		(stream<AudioSampleType> Aggregate_12_out0) as Aggregate_12 =
			Aggregate(Custom_10_out0 as inPort0Alias)
		{
			window
				inPort0Alias : tumbling, count(44), partitioned ;
			param
				partitionBy : id ;
			output
				Aggregate_12_out0 : id = id, sample = Sum(abs(sample)) ;
		}
*/
		(stream<AudioSample64Type> Functor_14_out0) as Functor_14 =
			Functor(Custom_10_out0)
		{
			output
				Functor_14_out0 : id = id, sample =(float64) Custom_10_out0.sample ;
		}
		/* 
		(stream<AudioFFTType> FFTout) as FFT_12 = FFT(Functor_14_out0 as AudioIn)
		{
			window
				AudioIn : sliding, count(2048), count(512) ;
			param
				algorithm : realFFT ;
				inputTimeSeries : sample ;
				useHamming : true ;
			output
				FFTout : magnitude = power() ;
		}
*/
///
		(stream<rstring id, list<complex64> complex> localPort as FFTout) as
			AudioFFT = FFT(Functor_14_out0 as audioIn)
		{
			window
				//audioIn : tumbling, count(4096) ;
				audioIn : sliding, count(4096), count(2048) ;
			param
				inputTimeSeries : sample ;
				algorithm : realFFT ;
				useHamming : true ;
			output
				localPort : complex = FFTAsComplex() ;
		}

		///
		(stream<AudioFFTAmpType> Custom_5_out0 as O) as AbsoluteFFT = Custom(localPort
			as I)
		{
			logic
				state :
				{
					mutable list<float64> ampList ;
					mutable int32 idx = 0 ;
				}

				onTuple I :
				{
					clearM(ampList) ;
					for(complex64 comp in I.complex)
					{
						appendM(ampList, abs(comp)) ;
					}

					submit({ id = id, ampFFT = ampList }, O) ;
				}

		}
		/**
		 * Generate full set of tiles, only move the the lowest 4 down the stream.
		 */
		(stream<AudioQuantileType> Tile_out0 as O) as Tile = Custom(Custom_5_out0 as
			I)
		{
			logic
				state :
				{
					mutable list<float64> stage = [ ] ;
					mutable float64 sliceTotal ;
					mutable uint32 sliceChunk ;
					mutable int32 sliceSize ;
					//				 	mutable int32 idx;

				}

				onTuple I :
				{
					clearM(stage) ;
					sliceTotal = sum(ampFFT) ;
					sliceSize = size(ampFFT) / 6 ;
					//for (float64 i in range(I.ampFFT));				
					for(int32 idx in range(0, size(ampFFT), sliceSize))
					{
						appendM(stage, sum(ampFFT [ idx : idx + sliceSize ]) / sliceTotal) ;
					}

					submit({ id = id, tile1 = stage [ 0 ], tile2 = stage [ 1 ], tile3 = stage
						[ 2 ], tile4 = stage [ 3 ] }, O) ;
				}

		}

		(stream<AudioQuantileType> Aggregate_6_out0) as AggregateTile =
			Aggregate(Tile_out0 as inPort0Alias)
		{
			window
				inPort0Alias : tumbling, count(8) ;
			output
				Aggregate_6_out0 : tile1 = Average(tile1), tile2 = Average(tile2), tile3 =
					Average(tile3), tile4 = Average(tile4) ;
		}

		() as FileSink_14 = FileSink(Functor_14_out0)
		{
			param
				file : "/dev/null" ;
				flush : 1u ;
		}

		() as FileSink_12 = FileSink(Aggregate_6_out0)
		{
			param
				file : "/dev/stdout" ;
		}

		() as WebSocketSend_13 = WebSocketSend(Filter_14_out0 as inPort0Alias)
		{
			param
				port : 8088 ;
			config
				placement : partitionColocation("jettyStatus") ;
		}

		(stream<AudioSample64Type> Filter_14_out0) as Filter_14 =
			Filter(Functor_14_out0 as inPort0Alias)
		{
			logic
				state : mutable int64 idx = 0 ;
			param
				filter :(id[0] == "+") && (idx ++ %(int64) 2) == (int64) 0 ; // count pluses + 1
		}

}

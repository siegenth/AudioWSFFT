namespace application ;

use com.ibm.streamsx.inet.rest::HTTPTupleView ;
use com.ibm.streamsx.inet.wsserver::WebSocketInject ;
use com.ibm.streamsx.inet.rest::WebContext ;
use com.ibm.streamsx.json::JSONToTuple ;
use com.ibm.streamsx.json::TupleToJSON ;
use com.ibm.streamsx.inet.wsserver::WebSocketSend ;
type BinaryDataType = tuple<blob outBlob> ;
type AudioDataType = tuple<rstring id, rstring command, uint64 size,
	blob outBlob, rstring signalData> ;
type AudioSignalType = tuple<rstring id, rstring signalData> ;
type AudioCommandType = tuple<rstring id, rstring command,
	rstring commandData> ;
type SimpleTuple = tuple<rstring data> ;
int64 getMilliseconds(timestamp ts)
{
	return(getSeconds(ts) * 1000l) +(int64)(getNanoseconds(ts) / 1000000u) ;
}
/**
 * Convert A 2 character string to binary value.
 * Yes this can be collapsed, but you can see this. 
 */
uint8 hexToInt(list<uint8> cvt)
{
	mutable uint8 l, h ;
	mutable uint8 low, high ;
	l = cvt [ 0 ] -(uint8) 48 ;
	h = cvt [ 1 ] -(uint8) 48 ;
	list<uint8> mapp = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0, 10,
		11, 12, 13, 14, 15 ] ;
		//////////////////// 0, 1, 2, 3, 4, 5, 6. 7, 8, 9, :, ;, <, =, >, ?, @,  A, B, C, D, E, F
	low = mapp [ l ] << 4 ;
	high = mapp [ h ] ;
	return(low | high) ;
}

composite AudioSample
{
	graph
		() as WebContext_3 = WebContext()
		{
			param
			// URL : http:<IP>:8081//html gets to index.thml 
			//       in "/home/streamsadmin/Development/html" ;  
				context : "html" ; // notice, no leading '/',  
				//contextResourceBase : getThisToolkitDir() + "/opt/html" ;
				// set to development directory so I can change things rapidly,
				// without redeploying the application. 
				//contextResourceBase : "/mnt/streamsadmin/Development/html" ;
				//contextResourceBase : "/xxxxx";
				contextResourceBase : "/mnt/hgfs/shareVM/CROSSDEV/audio/opt/html" ;
				// NOTE the only way I got this to work is to mess up the Data directory
				// that is set on the build??? I should be to the opt directory. 
				port : 8080 ;
		}

		(stream<rstring data> WebSocketInject_2_out0) as WebSocketInject_2 =
		//(stream<list<uint16> data> WebSocketInject_2_out0) as WebSocketInject_2 =
		WebSocketInject()
		{
			param
				port : 8086 ;
			config
				placement : partitionColocation("jettyStatus") ;
		}

		(stream<AudioDataType> Custom_7_out0 as DataOut ; stream<AudioCommandType>
			Custom_7_out1 as ControlOut) as WSSocketProcess =
			Custom(WebSocketInject_2_out0 as RawIn)
		{
			logic
				state :
				{
					mutable int32 messageCount = 0 ;
					list<uint8> resetOut = [ ] ;
					mutable list<uint8> out ;
					mutable BinaryDataType bdt ;
					mutable list<uint8> cvt ;
					mutable int32 hash1, hash2 ;
					mutable AudioDataType adt ;
					mutable AudioCommandType act ;
				}

				onTuple RawIn :
				{
					messageCount ++ ;
					out = resetOut ;
					if((length(data) != 0) &&(data [ 0 ] == "#"))
					{
						hash1 = findFirst(data, "#", 1) ;
						if(hash1 != - 1)
						{
							hash2 = findFirst(data, "#", hash1 + 1) ;
							if(hash2 != - 1)
							{
								adt.id = data [ 1 : hash1 ] ;
								adt.command = data [ hash1 + 1 : hash2 ] ;
								if((messageCount % 10) == 0)
								{
									appLog(Log.info, "messageCount:" +(rstring) messageCount + " id:" +
										adt.id + " command:" + adt.command + " length:" +(rstring)
										length(data)) ;
								}

								if(adt.command == "DATA")
								{
									cvt =(list<uint8>) convertToBlob(data [ hash2 + 1 : ]) ;
									for(int32 i in range(0, size(cvt), 2))
									{
										appendM(out, hexToInt(cvt [ i : i + 2 ])) ;
									}

									adt.outBlob =(blob) out ;
									adt.size = blobSize(adt.outBlob) ;
									adt.signalData = data [ hash2 + 1 : ] ;
									submit(adt, DataOut) ;
									return ;
								}

								act.command = adt.command ;
								act.id = adt.id ;
								act.commandData = data [ hash2 + 1 : ] ;
								appLog(Log.info, "ID: " + act.id + " COMMMAND:" + act.command) ;
								if(act.command == "STOP")
								{
									submit(Sys.WindowMarker, DataOut) ;
								}
								// All commands other the 'DATA' are sent down the line. 
								submit(act, ControlOut) ;
								return ;
							}

						}

					}

					act.id = "*UNKNOWN ID*" ;
					act.command = "UNKNOWN MESSAGE" ;
					act.commandData = data ;
					appLog(Log.warn, "Unknown message received : " + act.commandData [ : 40
						]) ;
					submit(act, ControlOut) ;
				}

		}
		/** 
		 * Only send out the binary data to file. 
		 */
		(stream<BinaryDataType> Functor_8_out0) as StripBlobAudio =
			Functor(Custom_7_out0 as wavStreamOut)
		{
		}
		/**
		 * Write the binary data, when file closes send down the file name.
		 */
		(stream<rstring fileName> FileSink_7_out1) as WriteBlobAudio =
			FileSink(Functor_8_out0 as inPort0Alias)
		{
			param
				file : "/tmp/STRM{localtime:%d%M}{id}.wavraw" ;
				closeMode : punct ;
				format : block ;
				flush :(uint32) 1 ;
		}

		(stream<AudioCommandType> Functor_7_out0) as FileNameFormat =
			Functor(FileSink_7_out1)
		{
			output
				Functor_7_out0 : id = "?", command = "STOP file closed", commandData =
					fileName ;
		}

		() as TraceSink = Custom(Custom_7_out1, Functor_7_out0 as inputStream)
		{
			logic
				onTuple inputStream :
				{
					appLog(Log.info, " ID:" + inputStream . id + "command:" + command + ":" +
						commandData) ;
				}

		}

		() as WebSocketSend_8 = WebSocketSend(Functor_10_out0 as inPort0Alias)
		{
			param
				port : 8087 ;
			config
				placement : partitionColocation("jettyStatus") ;
		}

		(stream<AudioSignalType> Functor_10_out0) as Functor_10 =
			Functor(Custom_7_out0 as inputStream)
		{
		}

}
